<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [多进制的那些事儿](#%E5%A4%9A%E8%BF%9B%E5%88%B6%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF)
  - [进制的转换](#%E8%BF%9B%E5%88%B6%E7%9A%84%E8%BD%AC%E6%8D%A2)
  - [正负数](#%E6%AD%A3%E8%B4%9F%E6%95%B0)
  - [二进制的按位操作](#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 多进制的那些事儿

二进制中的一个位`bit`是计算机中的最小单位。每八个二进制位构成一个字节`Byte`，而一个字节可以储存一个英文字母或者办个汉字。一个完整的二进制有 32 位，即 4 Byte；而完整的十六进制则有 8 位，每位代表 4 Byte

- `1 bit/b` 最小单位
- `1 byte/B` = `8 b`
- `1 KB` = `2^10 B` = `1024 B`
- `1 MB` = `2^10 KB` = `1024 KB` = `2^20 B`
- `1 GB` = `2^10 MB` = `1024 MB` = `2^30 B`
- `1 TB` = `2^10 GB` = `1024 GB` = `2^40 B`

---

对于二进制而言，每一位都由`0`和`1`组成，遇`2`则向前进位。同理，对于十六进制，每一位由`0`到`15`的十进制数字组成，遇`16`进位。但是在十六进制中，较为特殊的是，用`A`表示`10`，用`B`表示`11`，`C`表示`12`，`D`表示`13`，`E`表示`14`，`F`表示`15`

|二进制|十六进制|十进制|
|--|--|--|
|0000|0|0|
|0001|1|1|
|0010|2|2|
|0011|3|3|
|0100|4|4|
|0101|5|5|
|0110|6|6|
|0111|7|7|
|1000|8|8|
|1001|9|9|
|1010|A|10|
|1011|B|11|
|1100|C|12|
|1101|D|13|
|1110|E|14|
|1111|F|15|

### 进制的转换

十进制转为其他进制，只需辗转相除即可。而其他进制转为十进制，则按位计算乘法

例如，对于二进制`1101`而言，它相当于十进制的`1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0`，即`13`。

```text
二进制 1101 由 4 个位组成，从右向左分别是 0, 1, 2, 3 次幂（位数减 1）
则转为十进制则是
1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 13

同理，对于十六进制的数字，例如 79AC，转为十进制的过程为：
7 * 16^3 + 9 * 16^2 + 10 * 16^1 + 12 * 16^0 = 31148
```

类似的，当要把十进制数字转为其他进制时，则需要不断除以该进制的最大值，将其余数放置在每一位上。以`JavaScript`为例：

```javascript
// 暂时仅讨论正整数
// 转换为二进制。转为其他进制也是一样的思路
let num = 13
let result = '';

while (num) {
  result = `${num % 2}${result}`;
  num = Math.floor(num / 2);
}
console.log(result); // '1101'
```

当然，在各个编程语言中也已经内置了进制转换的函数。以`JavaScript`为例：

```javascript
// 将十进制转为其他进制
(13).toString(2); // 转为二进制，1101
(9).toString(8); // 转为八进制，11
(13).toString(16); // 转为十六进制，d

// 将其他进制转为十进制
parseInt(1101, 2); // 二进制转为十进制，13
parseInt(11, 8); // 八进制转为十进制，9
parseInt('d', 16); // 十六进制转为十进制，13
```

### 正负数

在其他进制中，将正数转为负数，则需要取正数的**补码**。一个数的补码，即该数每一位都取反，最后再加 1。例如，二进制的`1101`，写成完整的 32 位结构是`00000000 00000000 00000000 00001101`每一位都取反为`11111111 11111111 11111111 11110010`，再加 1 后成为`11111111 11111111 11111111 11110011`

```text
求十进制 -3 的十六进制表示方法，即是求十进制 3 的十六进制补码
十进制 3 转换为十六进制是 00000003，反码为 fffffffc（15 - 3 = 12，即 c）
最后再加 1 得到 fffffffd

求十进制 -5 的二进制
同理，十进制 5 的二进制表示为 00000000 00000000 00000000 00000101
则反码是 11111111 11111111 11111111 11111010
最后加 1 得到 11111111 11111111 11111111 11111011
```

在`JavaScript`中，可以利用`~`操作符获得按位取反的结果（反码）

```javascript
// 将十进制的 5 按位取反
~ 5 // -6
// 按位取反后加 1
~ 5 + 1 // -5，即十进制 5 的相反数
```

- [原码, 反码, 补码](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)
- [补码](https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8)

### 二进制的按位操作

- 按位与（AND）`a & b`

当两个位都是`1`时结果为`1`，否则为`0`

- 按位或（OR）`a | b`

当两个位至少有一个是`1`时结果为`1`，否则为`0`

- 按位异或（XOR）`a ^ b`

两个位上，只有一个是`1`时结果为`1`，否则为`0`

- 按位非（NOT）`~ a`

即二进制各个位上的反码

- 左移 `a << b`

向左移动`b`个比特位，空出来的右侧位置用`0`补全

- 有符号右移 `a >> b`

向右移动`b`个比特位

- 无符号右移 `a >>> b`

向右移动`b`个比特位，空出来的左侧位置用`0`补全

