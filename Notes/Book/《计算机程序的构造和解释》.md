<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [《计算机程序的构造和解释》读书记录](#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95)
  - [构造过程抽象](#%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B%E6%8A%BD%E8%B1%A1)
  - [构造数据抽象](#%E6%9E%84%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1)
  - [附：Scheme 基本教程](#%E9%99%84scheme-%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


# 《计算机程序的构造和解释》读书记录

- [《计算机程序的构造和解释》系列公开课](https://github.com/DeathKing/Learning-SICP)
- [《计算机程序的构造和解释（SICP）》讨论的核心问题是什么？](https://www.zhihu.com/question/26549715)
- [《计算机程序的构造和解释》豆瓣](https://book.douban.com/subject/1148282/)

> 计算机革命是有关我们如何去思考的方式，以及我们如何去表达自己的思考的一个革命。在描述一种语言时，应该将注意力集中到语言的基本原语、它的组合手段以及它的抽象手段上去。

## 构造过程抽象

心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：

1. 将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识 -- **组合**
2. 将两个认识放在一起对照，不管它们如何简单或者复杂，在这样做时并不将它们合而为一。由此得到有关它们的相互关系的认识 -- **对比**
3. 将有关认识与那些在实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的 -- **抽象**

一个强有力的程序设计语言，不仅是一种指挥计算机执行任务的方式，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。每一种强有力的语言都为此提供了三种机制：

1. 基本表达式：用于表示语言所关心的最简单的个体
2. 组合的方法：通过它们可以从较简单的东西出发构造出复合的元素
3. 抽象的方法：通过它们可以为复合对象命名，并将它们当做单元去操作

在程序设计中，我们需要处理两类要素：**过程和数据**。任何强有力的程序设计语言都必须能够表述基本的数据和基本的过程，还需要提供对过程和数据进行组合和抽象的方法。

解释器对语句求值的过程，分为*应用序*和*正则序*两种：

- 对于正则序求值，解释器会将语句完全展开然后规约。例如 Haskell
- 对于应用序求值，则先求值参数而后应用。例如 Lisp

```scheme
; 解释过程举例
(define (square x) (* x x))
(define (sum-of-square x y) (+ (square x) (square y)))

; 求值
(sum-of-square (+ 1 2) (+ 1 3))

; 对于正则序解释：
(sum-of-square (+ 1 2) (+ 1 3))
(+ (square (+ 1 2)) (square (+ 1 3)))
(+ (* (+ 1 2) (+ 1 2)) (* (+ 1 3) (+ 1 3)))
(+ (* 3 3) (* 4 4))
(+ 9 16)
(25)

; 对于应用序解释：
(sum-of-square (+ 1 2) (+ 1 3))
(sum-of-square 3 4)
(+ (square 3) (square 4))
(+ (* 3 3) (* 4 4))
(+ 9 16)
(25)
```

人们对功能强大的程序设计语言有一个必然要求，就是**能为公共的模式命名，建立抽象，而后直接在抽象的层次上工作**。而过程提供了这种能力，因此，除了最简单的程序语言以外，其他语言都包含定义过程的机制。但是即便在数值计算的过程中，如果将过程限制为只能以*数*作为参数，也会严重限制我们建立抽象的能力。经常有一些同样的程序设计模式能用于若干不同的过程。为了把这种模式描述为相应的概念，则需要构建出这样的过程：**以过程为参数，或者以过程为返回值。这类能操作过程的过程称为高阶过程**。

```scheme
; 考虑下面 2 个过程
; 1. 计算从 a 到 b 的各整数之和
(define (sum-integers a b)
  (if (> a b)
    0
    (+ a (sum-integers (+ a 1) b))))

; 2. 计算给定范围内的整数的立方之和
(define (sum-cubes a b)
  (if (> a b)
    0
    (+ (cube a) (sum-cubes (+ a 1) b))))

#|
可以看出这个两个过程共享了一样的基础模式：

(define (<name> a b)
  (if (> a b)
    0
    (+ (<term> a)
       (<name> (<next> a) b))))
|#
```

一般而言，程序设计语言总会对计算元素的可能使用方式强加上某些限制。带有最少限制的元素被称为具有第一级的状态。第一级元素的某些特权包括：

- 可以用变量命名
- 可以提供给过程作为参数
- 可以由过程作为结果返回
- 可以包含在数据结构中

## 构造数据抽象

将数据对象组合起来，形成复合数据 --> 为了提升我们在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。形成复合数据的关键则在于，程序设计语言里应该提供某种“黏合剂”，它们可以用于把一些数据对象组合起来，形成更复杂的数据对象。正如定义过程的能力使我们有可能在更高的概念层次上处理计算工作一样，能够构造复合数据的能力，也将使得我们可以在比语言提供的基本数据对象更高的概念层次上，处理与数据有关的各种能力。

- 过程抽象：将过程的使用方式，与该过程究竟如何通过更基本的过程实现的具体细节相互分离
- 数据抽象：将一个复合数据对象的使用，与该数据对象怎样由更基本的数据对象构造起来的细节隔离开

一般而言，数据抽象的基本思想就是为每一类数据对象标识出一组操作，使得对这类数据对象的所有操作都可以基于它们表述，而且在操作这些数据对象时也只能使用它们。使用数据抽象的程序与实现数据抽象的程序应隔离开。

层次性数据和闭包性质：

*某种组合数据对象的操作满足闭包性质，即代表，通过它组合起数据对象得到的结果本身，还可以通过同样的操作再进行组合。*闭包性质使我们能够建立起层次性的结构，这种结构由一些部分构成，而其中的各个部分又是由它们的部分构成，并可以如此继续下去。

复合结构`cons`可以组合两种元素，利用这种性质，可以把某一个元素作为节点的值，另一个元素指向下一个节点，以此构建出链表（序列）或者树。例如：

```scheme
(cons 1 (cons 2 (cons 3 nil)))

; 借助 cons，可以创建「有理数」这个复合数据对象 - 由整数分子和整数分母组成
(define (make-rat n d) (cons n d))
; 获取有理数的分子
(define (number x) (car x))
; 获取有理数的分母
(define (denom x) (cdr x))

; 例如 1/2
(define x (make-rat 1 2))
(number x) ; 1
(denom x); 2
```

甚至只用基本过程实现序对，即将序对这个数据结构用过程表示：

```scheme
; 返回一个过程
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else (error "Argument not 0 or 1 -- CONS" m))))
  dispatch)

(define (car z) (z 0))
(define (cdr z) (z 1))
```

scheme 本身也提供了基本操作`list`：

```scheme
(list 1 2 3)
(define arr (list 1 2 3))
(car arr) ; 1
(cdr arr); (2 3)
```

针对于序列这样的数据结构，我们可以抽象出各种高阶操作，例如对表的映射`map`，接收一个过程参数和一个表参数，将过程依次作用在表的各个元素上，并返回结果。

```scheme
; 表的映射 - 将某种变换应用于一个表的所有元素，得到由所有结果构成的表
; 抽取这一过程的公共模式：即
; 1. 如果表为空，则返回 nil
; 2. 否则利用 car 获取表中第一个元素，代入映射过程获取结果，并将 map 作用在表中剩下的元素上，最后合并为新表
(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))

(map (lambda (x) (* x x))
     (list 1 2 3 4))
```

这类操作建立起了一种处理表的高层抽象，抑制了细节层面的情况（例如，如何对表进行遍历，每个元素的处理结果如何返回），而强调的是一个表到另一个表的缩放变换。它将表变换的过程的实现，与如何提取表中元素以及组合结果的细节隔离开来。

将程序表示为一些针对序列的操作，帮助开发者得到模块化的程序设计，得到由一些比较独立的片段的组合构成的设计，以此控制复杂性。

一个复杂的系统应该通过一系列的层次构造出来。为了描述这些层次，需要使用一系列的语言。构造各个层次的方式，就是设法组合起作为这一层次中的部件的各种基本元素。而这样构造出的部件，又可以作为另一个层次里的基本元素。在分层设计中，每个层次上所用的语言都提供了一些基本元素、组合手段，还有对该层次中的适当细节做抽象的手段。

在复杂系统的工程中广泛使用这种分层设计方法。例如，在计算机工程里，电阻和晶体管被组合起来，产生出一些部件，例如与门、或门等等。这些门电路又被作为数字电路设计的语言的基本元素。将这类部件组合起来，构成了处理器、总线和存储系统。随即，又通过它们的组合构造出各种计算机。计算机的组合可以进一步构成分布式系统。

分层设计有助于使程序更加强健。也就是说，当我们要在给定范围发生一些小改变时，只需对程序作出少量的修改。一般来说，分层结构中的每个层次都为表述系统的特征提供了一套独特词汇，以及一套修改这一系统的方式。

## 附：Scheme 基本教程

- [Scheme 入门教程](https://github.com/DeathKing/yast-cn)

```scheme
; 组合：括号 + 表达式
(+ 1 3) ; 4
(* 2 3 4) ; 24
(- (* 2 3) (+ 4 5)) ; -3

; 命名
(define size 2)
(define pi 3.14159)
(define radius 10)
(* pi radius radius) 314.159

; 复合过程
(define (square x) (* x x))
; (define (<name> <parameters>) <body>)
(square 21) ; 441
(square (+ 2 5)) ; 49
(+ (square 3) (square 2)) ; 13
; 利用复合过程定义复合过程
(define (sum-of-squares x y)
  (+ (square x) (square y)))
(sum-of-squares 2 3) ; 13

#|
条件表达式和谓词
类似其他语言的 switch 或者 case
一般形式为

(cond (<p1> <e1>)
      ...
      (<pn> <en>))

首先包含了一个符号 cond，在它之后跟着一些称为子句的用括号括起来的表达式对偶 (<p> <e>)
在每个对偶中的第一个表达式是一个谓词（即 p），也就是说，这是一个表达式，它的值将被解释为真或者假
当某一个谓词为真时，返回后面的值，不再继续检查剩下的谓词
|#

(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))

(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))

; if 表达式
; (if <predicate><consequent><alternative>)
; 如果 predicate 为真，则求 consequent 的值并返回；否则求 alternative 的值并返回
(define (abs x)
  (if (< x 0)
      (- x)
      x))

#|
and/or/not 表达式

(and <e1> ... <en>) 全部表达式为真时返回真，否则返回假
(or <e1> ... <en>) 全部表达式为假时返回假，否则返回真
(not <e>)
|#
(and (> x 5) (< x 10)) ; 判断 5 < x < 10

; lambda 表达式
; (lambda (<parameters>) <body>)
(lambda (x) (+ 4 x))


#|
let 创建局部变量

(let ((<var1> <exp1>)
      (<var2> <exp2>)
      ...
      (<varn> <expn>))
    <body>)

创建的变量只在 body 块内有效
|#
; 38
(+ (let ((x 3))
        (+ x (* x 10)))
    5)

; null? 检查参数是否为空
(null? 1) ; #f

; pair? 检查参数是否是序对
(pair? 1) ; #f
(pair? (cons 1 2)) ; #t
```

```scheme
; 序对复合结构，可通过 cons 构造。cons 取两个参数，返回一个包含这两个参数作为其成分的复合数据对象
(define x (cons 1 2))
; 从序对构造起来的数据对象成为表结构数据
; 可利用基本过程 car 和 cdr 从该复合数据对象中提取各个部分
(car x) ; 1
(cdr x) ; 2

; 一个序对也是一个数据结构，可以像基本数据对象一样继续操作
(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))
(car (car z)) ; 1
(car (cdr z)) ; 3

; 通过嵌套的 cons 可以形成一个链表：
; cons 的 car 储存当前节点的值，而 cdr 则储存下一个节点。在最后一个节点，cdr 为 nil
; scheme 本身提供了这样的基本操作 list
(list 1 2 3 4)
; 等价于
(cons 1 (cons 2 (cons 3 (cons 4 nil))))
```
